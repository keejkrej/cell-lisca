cell-tensionmap: Tension Inference
===================================

cell-tensionmap is the fourth module in the Cell-LISCA pipeline, providing integration with TensionMap for stress tensor inference from segmentation data.

Overview
--------

The cell-tensionmap module provides a simple interface to run VMSI (Vertex Model Stress Inference) on segmentation masks generated by the Cell-LISCA pipeline. It calculates cellular stress tensors and morphometrics from cell geometry.

This module requires the external TensionMap package to be installed separately.

Command Line Interface
----------------------

Basic Usage
~~~~~~~~~~~

.. code-block:: bash

   cell-tensionmap run --mask segmentation.npy --output model.pkl

Or via Python module:

.. code-block:: bash

   python -m cell_tensionmap run --mask segmentation.npy --output model.pkl

Command Options
~~~~~~~~~~~~~~~

.. option:: --mask <PATH>

   Path to segmentation mask .npy file (required).

.. option:: --output <PATH>

   Path to save the VMSI model (pickle) (optional).

.. option:: --labelled

   Mask already labelled (default: ``True``).

.. option:: --optimiser <STRING>

   Optimiser for VMSI (``nlopt`` or ``matlab``). Default: ``nlopt``

.. option:: --verbose

   Enable verbose output.

Examples
~~~~~~~~

.. code-block:: bash

   # Basic analysis
   cell-tensionmap run --mask segmentation.npy

   # Save model to file
   cell-tensionmap run --mask segmentation.npy --output stress_model.pkl

   # Use MATLAB optimiser
   cell-tensionmap run --mask segmentation.npy --optimiser matlab --verbose

Input Requirements
------------------

Segmentation Mask Format
~~~~~~~~~~~~~~~~~~~~~~~

The mask should be a NumPy array saved with ``np.save``:

- **Shape**: ``(T, H, W)`` for timelapse or ``(H, W)`` for single frame
- **Values**: Integer labels for each cell (background=0, cells=1,2,3,...)
- **Type**: Integer array (int32, uint16, etc.)

Example:

.. code-block:: python

   # Single frame segmentation
   segmentation = np.array([
       [0, 0, 1, 1, 2, 2],
       [0, 0, 1, 1, 2, 2],
       [3, 3, 4, 4, 5, 5],
       [3, 3, 4, 4, 5, 5]
   ], dtype=np.int32)
   np.save('segmentation.npy', segmentation)

   # Timelapse segmentation
   segmentation_timelapse = np.array([frame1, frame2, frame3, ...], dtype=np.int32)
   np.save('segmentation_timelapse.npy', segmentation_timelapse)

Data Sources
~~~~~~~~~~~~

The segmentation mask can come from:

1. **cell-filter output**: Extract the segmentation channel from NPY files
2. **cell-grapher output**: Use tracked segmentation with global IDs
3. **Custom segmentation**: Any properly formatted segmentation mask

Extracting Segmentation from Cell-Filter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   import numpy as np

   # Load NPY file from cell-filter
   data = np.load('fov_000_pattern_000_seq_000.npy')
   
   # Segmentation is the last channel
   segmentation = data[:, -1, :, :]  # All frames, last channel
   
   # Save for tensionmap
   np.save('segmentation.npy', segmentation)

Output Format
-------------

VMSI Model Object
~~~~~~~~~~~~~~~~~

The output is a pickled VMSI model object containing:

- **Stress Tensors**: Per-cell stress tensor matrices
- **Morphometrics**: Cell shape measurements
- **Vertex Positions**: Coordinates of cell vertices
- **Edge Properties**: Properties of cell-cell interfaces
- **Metadata**: Analysis parameters and settings

Accessing Results
~~~~~~~~~~~~~~~~~

.. code-block:: python

   import pickle
   
   # Load saved model
   with open('model.pkl', 'rb') as f:
       model = pickle.load(f)
   
   # Access stress tensors
   stress_tensors = model.stress_tensors
   
   # Access morphometrics
   cell_areas = model.cell_areas
   cell_perimeters = model.cell_perimeters
   
   # Access vertex positions
   vertices = model.vertices

API Usage
---------

Python API
~~~~~~~~~~

.. code-block:: python

   from cell_tensionmap.integration import run_tensionmap_analysis
   import numpy as np

   # Load segmentation mask
   mask = np.load('segmentation.npy')
   
   # Run VMSI analysis
   model = run_tensionmap_analysis(
       mask,
       is_labelled=True,
       optimiser='nlopt',
       verbose=True
   )
   
   # Access results
   print(f"Analyzed {model.n_cells} cells")
   print(f"Average stress: {np.mean(model.stress_tensors)}")

Advanced Options
~~~~~~~~~~~~~~~~

.. code-block:: python

   model = run_tensionmap_analysis(
       mask,
       is_labelled=True,
       holes_mask=None,  # Optional mask for tissue holes
       tile=False,       # Tile large tissues
       cells_per_tile=150,
       overlap=0.3,
       optimiser='nlopt',
       verbose=True
   )

Core Functions
~~~~~~~~~~~~~~

.. autofunction:: cell_tensionmap.integration.run_tensionmap_analysis

Installation
------------

TensionMap Dependency
~~~~~~~~~~~~~~~~~~~~~

cell-tensionmap requires the external TensionMap package:

.. code-block:: bash

   # Install TensionMap (follow official installation guide)
   pip install tensionmap

   # Or from source
   git clone https://github.com/your-repo/tensionmap
   cd tensionmap
   pip install -e .

Note: TensionMap may have additional dependencies:
- MATLAB (for MATLAB optimiser)
- NLopt (for nlopt optimiser)
- Specific Python packages (check TensionMap docs)

Algorithm Details
-----------------

VMSI Overview
~~~~~~~~~~~~~

Vertex Model Stress Inference (VMSI) calculates cellular stresses by:

1. **Vertex Detection**: Identify cell vertices from segmentation
2. **Edge Extraction**: Find cell-cell interfaces
3. **Force Balance**: Apply force balance equations at each vertex
4. **Stress Calculation**: Infer stress tensors from geometry
5. **Optimization**: Minimize error in force balance

Key Assumptions
~~~~~~~~~~~~~~~

- Cells are in mechanical equilibrium
- Cell boundaries transmit tension
- Vertex forces sum to zero (force balance)
- Stress is uniform within each cell

Output Metrics
~~~~~~~~~~~~~~

The VMSI analysis provides:

- **Stress Tensor**: 2x2 matrix per cell
- **Principal Stresses**: Max/min eigenvalues
- **Stress Direction**: Principal stress orientation
- **Cell Shape**: Area, perimeter, aspect ratio
- **Interface Tensions**: Tension along each edge

Performance Considerations
--------------------------

Computational Complexity
~~~~~~~~~~~~~~~~~~~~~~~

- Scales with number of cells and vertices
- Optimization step is most time-consuming
- Memory usage depends on tissue size

Optimization Tips
~~~~~~~~~~~~~~~~

1. **Tiling**: Use tiling for very large tissues
2. **Optimiser Choice**: nlopt is typically faster than MATLAB
3. **Simplification**: Reduce segmentation complexity if possible
4. **Parallel Processing**: Some operations can be parallelized

Troubleshooting
---------------

Common Issues
~~~~~~~~~~~~~

1. **ImportError: TensionMap not found**
   - Install TensionMap package
   - Check Python path configuration

2. **Convergence Issues**
   - Try different optimiser
   - Check segmentation quality
   - Ensure proper labeling

3. **Memory Errors**
   - Use tiling for large datasets
   - Reduce image resolution
   - Process frames individually

4. **Poor Results**
   - Verify segmentation accuracy
   - Check for labeling errors
   - Ensure proper boundary conditions

Validation
~~~~~~~~~~

Check your input before running:

.. code-block:: python

   import numpy as np
   
   mask = np.load('segmentation.npy')
   
   # Check format
   assert mask.dtype.kind in {'i', 'u'}, "Mask must be integer"
   assert mask.min() == 0, "Background should be 0"
   assert mask.max() > 0, "Should have at least one cell"
   
   # Check connectivity
   unique_labels = np.unique(mask)
   print(f"Found {len(unique_labels)-1} cells")

Integration with Pipeline
------------------------

Cell-tensionmap is typically used after cell-grapher in the Cell-LISCA pipeline:

1. **cell-pattern extract** → Pattern detection
2. **cell-filter analysis + extract** → Cell counting and segmentation
3. **cell-grapher** → Cell tracking (optional)
4. **cell-tensionmap** → Stress inference from segmentation
5. **Analysis** → Combine tracking and stress data

Example Workflow
~~~~~~~~~~~~~~~~

.. code-block:: python

   # Complete workflow from cell-filter to tension analysis
   import numpy as np
   from cell_tensionmap.integration import run_tensionmap_analysis
   
   # 1. Load cell-filter output
   data = np.load('sequence.npy')
   
   # 2. Extract segmentation (last channel)
   segmentation = data[:, -1, :, :]
   
   # 3. Analyze each frame
   stress_results = []
   for frame_idx, seg in enumerate(segmentation):
       model = run_tensionmap_analysis(
           seg,
           is_labelled=True,
           verbose=False
       )
       stress_results.append(model.stress_tensors)
   
   # 4. Combine with tracking data if available
   tracking_data = np.load('tracked_cells.npy', allow_pickle=True)
   # Correlate stress with cell movements

Applications
------------

The stress analysis from cell-tensionmap can be used for:

- **Mechanobiology**: Study how cells generate and respond to forces
- **Developmental Biology**: Understand stress patterns in development
- **Disease Modeling**: Analyze mechanical changes in disease
- **Tissue Engineering**: Optimize scaffold mechanical properties
